route grid spawn route_grid_spawn


shared grid_data = load_json_data(get_mission_dir_filename("grid_data.json"))

======== spawn_grid_objects ========
#
# Called by basic_ai, so we know this is a player ship already
#
jump rebuild_grid_items 
->END

====== rebuild_grid_items =====
->END if grid_data is None
so = to_object(SPAWNED_ID)
->END if so is None
ship_grid  = grid_data.get(so.art_id)
->END if ship_grid is None
internal_items = ship_grid.get("grid_objects")
->END if internal_items is None

#
# This gets the starting color of damcons
# Replace this later to create the damcons
#
dcs = to_object_list(grid_objects(sim, SPAWNED_ID) & role("damcons"))
for dc in dcs:
    blob = to_blob(sim, dc)
    color = blob.get("icon_color", 0)    
    do set_inventory_value(dc, "color", color)
next dc


# Delete all grid objects
items = linked_to(SPAWNED_ID, "grid_objects")
for k in items:
    # delete by id
    do sbs.delete_grid_object(SPAWNED_ID, k)
next k


#
# Got data build grid objects
#
i=0 # used to create unique tag
sensors = 0 # used to calculate max damage
engines = 0
weapons = 0
shields = 0
for g in internal_items:
    loc_x = int(g["x"])
    loc_y = int(g["y"])
    coords = f"{loc_x},{loc_y}"
    name_tag = f"{g['name']}:{coords}"

    go =  grid_spawn(SPAWNED_ID,  name_tag, name_tag, loc_x, loc_y, g["icon"], g["color"], g["roles"])
    do go.blob.set("icon_scale", g["scale"], 0)
    # save color so it cn be restored
    do set_inventory_value(go.id, "color", g["color"])
    #
    # Add link so query can find this relationship
    #       e.g. query to find engine grid objects on a ship
    #       linked_to(player_id, "grid_objects") & role("engine")
    #
    do link(so, "grid_objects",go)
    do add_role(go, "__undamaged__")
    i+=1

    #
    # Update max damage counts
    #
    roles = g["roles"].lower()
    if "sensors" in roles:
        sensors += 1
    end_if
    if "engine" in roles:
        engines += 1
    end_if
    if "shield" in roles:
        shields += 1
    end_if
    if "weapon" in roles:
        weapons += 1
    end_if
next g
blob = to_blob(sim, so)
do  blob.set('system_max_damage', weapons, sbs.SHPSYS.WEAPONS)
do  blob.set('system_max_damage', engines, sbs.SHPSYS.ENGINES)
do  blob.set('system_max_damage', sensors, sbs.SHPSYS.SENSORS)
do  blob.set('system_max_damage', shields, sbs.SHPSYS.SHIELDS)
do  blob.set('system_damage', 0, sbs.SHPSYS.WEAPONS)
do  blob.set('system_damage', 0, sbs.SHPSYS.ENGINES)
do  blob.set('system_damage', 0, sbs.SHPSYS.SENSORS)
do  blob.set('system_damage', 0, sbs.SHPSYS.SHIELDS)


->END



========== route_grid_spawn =========
# AI for the player is the docking logic
jump damcon_ai if has_role(SPAWNED_ID, "damcons")

#### ELSE don't run a task
->END



========== damcon_ai  ================= 

this_blob = get_engine_data_set(sim, SPAWNED_ID)

# The damcons is no longer
->END if this_blob is None


length = this_blob.get("path_length", 0)
if length is None or length < 1:
    # check for garbage and mop up
    obj = to_object(SPAWNED_ID)
    x = this_blob.get("curx", 0)
    y = this_blob.get("cury", 0)
    
    # Damcon is no more
    ->END if obj is None

    # Host is no more 
    hm = sbs.get_hull_map(obj.host_id)
    ->END if hm is None

    #
    # Get the points at this location
    #
    at_point = hm.get_objects_at_point(x,y)
    
    for id in at_point:
        # Only deal with Damage
        if not has_role(id, "__damaged__"):
            continue
        end_if
        if has_role(id, "damcons"):
            continue
        end_if

        go = to_object(id)
        if go is None:
            continue
        end_if


        # Have to unlink this so it is no longer seen
        do unlink(obj.host_id, "damage", id)
        do unlink(SPAWNED_ID, "assigned", id )
        # Remove work order
        do unlink(SPAWNED_ID, "work-order", id)


        # If hallway damage delete
        # else restore color and repair system
        system_heal = None # get_inventory_value(go, "system")
        if has_role(id, "hallway"):
            do sbs.delete_grid_object(go.host_id, id)
            do go.destroyed()
        #
        # This is a room, fix
        #
        else:
            blob = to_blob(sim, id)
            color = get_inventory_value(id, "color")
            if color is None:
                color = "purple"
            end_if
            do blob.set("icon_color", color, 0)
            if has_role(id, "sensors"):
                system_heal = sbs.SHPSYS.SENSORS
            elif has_role(id, "weapon"):
                system_heal = sbs.SHPSYS.WEAPONS
            elif has_role(id, "engine"):
                system_heal = sbs.SHPSYS.ENGINES
            elif has_role(id, "shield"):
                system_heal = sbs.SHPSYS.SHIELDS
            end_if
        end_if
        #
        # 
        #
        if system_heal is not None:
            ship_blob = get_engine_data_set(sim, go.host_id)
        
            current = ship_blob.get('system_damage', system_heal)
            if current >0:
                do ship_blob.set('system_damage', current-1 , system_heal)
            else:
                do ship_blob.set('system_damage', 0 ,  system_heal)
            end_if
        end_if
    next id
        
    # Then look for more work
    # Find damage that is not assigned to someone else

    # the_target = grid_closest(sim, SPAWNED_ID, linked_to(obj.host_id, "damage")-has_link("assigned_to"))
    #
    # The damage needs to be a work order for a damcon
    #
    the_target =  grid_closest(sim, SPAWNED_ID, linked_to(SPAWNED_ID, "work-order"))
    if the_target is not None:
        do grid_target(sim, SPAWNED_ID, the_target)
        # Remove from available assignments
        do link(the_target, "assigned_to", SPAWNED_ID)
        do link(SPAWNED_ID, "assigned", the_target )
    else:
        do grid_target_pos(sim, SPAWNED_ID, obj.spawn_pos.x, obj.spawn_pos.y)
    end_if
end_if

#
# Loop while this damcon lives
#
delay sim 5s
-> damcon_ai


