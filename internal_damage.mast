route damage internal take_internal_damage


======== take_internal_damage  =======
# This called when there is damage being taken internally
#
# The DAMAGE_ORIGIN_ID is the ship being damaged
# EVENT has the event data sub_float has the amount, source_point has the point
#


# Make sure you don't take further damage
if has_role(DAMAGE_ORIGIN_ID, "exploded"):
    ->END
end_if

# Host is no more 
hm = sbs.get_hull_map(DAMAGE_ORIGIN_ID)
->END if hm is None

loc_x = 0
loc_y = 0
damage_radius = int(((hm.w+hm.h) / 2 / 2) + 2) # Average halved + 2

loc = sbs.find_valid_grid_point_for_vector3(DAMAGE_ORIGIN_ID, EVENT.source_point, damage_radius)

#
# pick a random system 
# this can get overridden by finding a grid object in the hit location
#
system_hit = random.randint(0,3)
blob = get_engine_data_set(sim, DAMAGE_ORIGIN_ID)
damage_amount = EVENT.sub_float
icons = [40,59,33,27]
colors = ["red", "red", "red", "red"]

if len(loc)>0:
    loc_x = loc[0]
    loc_y = loc[1]
    # do print(f"{loc_x} {loc_y} {EVENT.source_point.x} {EVENT.source_point.y} {EVENT.source_point.z}")
    go_set_at_loc = grid_objects_at(DAMAGE_ORIGIN_ID, loc_x, loc_y)
    #
    # If empty hallway hit, Drop damage down 
    #
    if len(go_set_at_loc) == 0:
        dam_go = grid_spawn(DAMAGE_ORIGIN_ID, f"damage", "", loc_x,loc_y, icons[system_hit], colors[system_hit], "__damaged__") 
        do link(DAMAGE_ORIGIN_ID, "damage", to_id(dam_go))
        do dam_go.blob.set("icon_scale", 0.75, 0)
   else:
   #    do print("got some")
        #
        # there are things here
        #
        #
        # Try several times to apply damage
        # if damage is applied just do it once
        #
        num_retry = 3
        for retry in range(num_retry):
            already_damaged = False
            for go_id in go_set_at_loc:
                if has_role(go_id, "__damaged__"):
                    already_damaged = True
                    continue
                end_if
                go = to_object(go_id)
                blob = to_blob(sim, go_id)
                do blob.set("icon_color", "red", 0)
                do link(DAMAGE_ORIGIN_ID, "damage", go_id) 
                do add_role(go_id, "__damaged__")
                do remove_role(go_id, "__undamaged__")
            next go 
            #
            # I all damage was new, we are done
            #
            if not already_damaged:
                break
            end_if
            #
            # otherwise
            # find closest undamaged thing, not hallways
            # Using it's x,y as the new place to try
            #
            a_go = next(iter(go_set_at_loc))
            undam = grid_closest(sim, a_go, role("__undamaged__") & linked_to(DAMAGE_ORIGIN_ID, "grid_objects"))
            #
            # Just need one item to get x,y
            #
            if undam is not None:
                go_blob = to_blob(sim, undam)
                loc_x = int(go_blob.get("curx", 0))
                loc_y = int(go_blob.get("cury", 0))

                do print("{loc_x} {loc_y}")
                go_set_at_loc = grid_objects_at(DAMAGE_ORIGIN_ID, loc_x, loc_y)
            end_if
        next retry
    end_if
else:
    do print(f"NO SOUP {EVENT.source_point.x} {EVENT.source_point.y} {EVENT.source_point.z}")
end_if
    

->END

===== dead_code_but_need_parts ===
        #
        # Deal damage evenly, but start at a random system
        #
        # Get open hull points
        points = get_inventory_value(DAMAGE_ORIGIN_ID, "undamaged")
        #
        # I we haven't set it then get the valid grid points
        #
    #    if points is None:
    #        points = get_open_grid_points(sim,DAMAGE_ORIGIN_ID)
    #       #
            # Maybe remove some?
            #
    #        do set_inventory_value(DAMAGE_ORIGIN_ID, "undamaged", points)
    #    end_if



if len(points)>0:
    point = None

    if loc_x > 0 and loc_y > 0:
    else:
        point = random.choice(points)
        #do print(f"point {point}")
    end_if

    do points.remove(point)
    do set_inventory_value(DAMAGE_ORIGIN_ID, "undamaged", points)

    dam_go = grid_spawn(DAMAGE_ORIGIN_ID, f"damage", "", point[0],point[1], icons[system_hit], colors[system_hit], "damage")
    #
    # Keep track of the type of damage
    #
    do set_inventory_value(dam_go, "system", system_hit)
    #
    # The damage needs to be linked to the ship
    #
    do link(DAMAGE_ORIGIN_ID, "damage", to_id(dam_go)) 
    do dam_go.blob.set("icon_scale", 0.75, 0)
end_if    

#
# Apply damage even if you can't find a spot
#
#do print(f"Applying internal damage {damage_amount}")

max_dam = blob.get('system_max_damage', system_hit)
current = blob.get('system_damage', system_hit)
if current <= max_dam:
    do blob.set('system_damage', current+0.5 ,  system_hit)
else:
    do blob.set('system_damage', max_dam ,  system_hit)
end_if
#    do print(f"system_damage {system_hit} dam {current+1}")




# Is this the end?
should_explode = True

for sys in range(4):
    max_damage = blob.get('system_max_damage', sys)
    current = blob.get('system_damage', sys)
    if current < max_damage:
        should_explode = False
        break
    end_if
next sys

if should_explode:
    #
    # type, subtype, source_id, target_id, x, y, z, side
    #
    pos = get_pos(sim, EVENT.origin_id)
    if pos:
        do sbs.create_transient(1, 0, EVENT.origin_id, 0, EVENT.parent_id, pos.x, pos.y, pos.z, "")  
    end_if

    do add_role(EVENT.origin_id, "exploded")

    so = to_object(EVENT.origin_id)
    engine_obj = so.space_object(sim)
    art_id = so.art_id
    do so.set_art_id(sim,"invisible")

    # Reset the systems to max
    for sys in range(4):
        do blob.set('system_damage', 0, sys)
    next sys
    
    delay sim 5s
    #
    # Reuse the score update by spawning it ourselves
    #
    schedule update_score {"DESTROYED_ID": EVENT.origin_id}

    do sim.reposition_space_object(engine_obj, so.spawn_pos.x, so.spawn_pos.y, so.spawn_pos.z)
    do so.set_art_id(sim,art_id)
    do remove_role(EVENT.origin_id, "exploded")

end_if
->END