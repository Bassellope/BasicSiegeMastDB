route damage internal take_internal_damage
route damage heat take_heat_damage


======== take_heat_damage  =======
# This called when there is damage being taken from heat
#
# The DAMAGE_ORIGIN_ID is the ship being damaged
# EVENT has the event data sub_float has the system
#

# Make sure you don't take further damage
->END if has_role(DAMAGE_ORIGIN_ID, "exploded")


#   WEAPONS : 0, ENGINES : 1, SENSORS : 2, SHIELDS : 3
system_damage = [0,0,0,0]
the_roles =  ["weapon", "engine", "sensors", "shield"]
hit_system = int(EVENT.sub_tag)
the_role = the_roles[hit_system]
#
# Find undamaged system, apply damage to it
#
# from grid objects on this ship that are undamaged and match the system
#
hittable = to_list(grid_objects(sim, DAMAGE_ORIGIN_ID) & role("__undamaged__") & role(the_role))
#
# If no more of that system left just exit
#
->END if len(hittable) == 0

do system_damage[hit_system]  += 1
#
# Pick one of the valid items
# and damage it
#
go_id = random.choice(hittable)

blob = to_blob(sim, go_id)
do blob.set("icon_color", "red", 0)
do link(DAMAGE_ORIGIN_ID, "damage", go_id) 
do add_role(go_id, "__damaged__")
do remove_role(go_id, "__undamaged__")

jump apply_system_damage

======== take_internal_damage  =======
# This called when there is damage being taken internally
#
# The DAMAGE_ORIGIN_ID is the ship being damaged
# EVENT has the event data sub_float has the amount, source_point has the point
#


# Make sure you don't take further damage
->END if has_role(DAMAGE_ORIGIN_ID, "exploded")

# Host is no more 
hm = sbs.get_hull_map(DAMAGE_ORIGIN_ID)
->END if hm is None

loc_x = 0
loc_y = 0
damage_radius = int(((hm.w+hm.h) / 2 / 2) + 2) # Average halved + 2

loc = sbs.find_valid_grid_point_for_vector3(DAMAGE_ORIGIN_ID, EVENT.source_point, damage_radius)

#
# pick a random system 
# this can get overridden by finding a grid object in the hit location
#
system_hit = int(EVENT.sub_float)
blob = get_engine_data_set(sim, DAMAGE_ORIGIN_ID)
damage_amount = EVENT.sub_float

#   WEAPONS : 0, ENGINES : 1, SENSORS : 2, SHIELDS : 3
system_damage = [0,0,0,0]

# Nothing to do END
->END if len(loc)== 0

loc_x = loc[0]
loc_y = loc[1]
# do print(f"{loc_x} {loc_y} {EVENT.source_point.x} {EVENT.source_point.y} {EVENT.source_point.z}")
go_set_at_loc = grid_objects_at(DAMAGE_ORIGIN_ID, loc_x, loc_y)

#
# If empty hallway hit, Drop damage down 
#
jump damage_hallway if len(go_set_at_loc) == 0
   

#
# there are things here
#
#
# Try several times to apply damage
# if damage is applied just do it once
#
num_retry = 3

injured_dc = set()
for retry in range(num_retry):
    already_damaged = False
    
    for go_id in go_set_at_loc:
        #
        # track hit damcons
        #
        if has_role(go_id, "damcons"):
            do injured_dc.add(go_id)
            # don't mark damcons as damaged
            continue
        end_if
        if has_role(go_id, "marker"):
            # don't mark marker as damaged
            continue
        end_if
        if has_role(go_id, "__damaged__"):
            already_damaged = True
            continue
        end_if
        go = to_object(go_id)
        blob = to_blob(sim, go_id)
        do blob.set("icon_color", "red", 0)
        do link(DAMAGE_ORIGIN_ID, "damage", go_id) 
        do add_role(go_id, "__damaged__")
        do remove_role(go_id, "__undamaged__")
        if has_role(go_id, "weapon"):
            do system_damage[sbs.SHPSYS.WEAPONS]  += 1
        end_if
        if has_role(go_id, "sensors"):
            do system_damage[sbs.SHPSYS.SENSORS]  += 1
        end_if
        if has_role(go_id, "shield"):
            do system_damage[sbs.SHPSYS.SHIELDS]  += 1
        end_if
        if has_role(go_id, "engine"):
            do system_damage[sbs.SHPSYS.ENGINES]  += 1
        end_if
    next go 
    #
    # I all damage was new, we are done
    #
    if not already_damaged:
        break
    end_if
    #
    # otherwise
    # find closest undamaged thing, not hallways
    # Using it's x,y as the new place to try
    #
    a_go = next(iter(go_set_at_loc))
    undam = grid_closest(sim, a_go, role("__undamaged__") & linked_to(DAMAGE_ORIGIN_ID, "grid_objects"))
    #
    # Just need one item to get x,y
    #
    if undam is not None:
        go_blob = to_blob(sim, undam)
        loc_x = int(go_blob.get("curx", 0))
        loc_y = int(go_blob.get("cury", 0))

        #do print(f"{loc_x} {loc_y}")
        go_set_at_loc = grid_objects_at(DAMAGE_ORIGIN_ID, loc_x, loc_y)
    end_if
next retry

for d in injured_dc:
    hp =  get_inventory_value(d, "HP", 0)
    hp -= 1
    do  set_inventory_value(d, "HP", hp)
    go = to_object(d)
    ship = go.host_id 
    blob = to_blob(sim, d)
    do blob.set("icon_color", "red", 0)
    if hp <= 0:
        do sbs.delete_grid_object(go.host_id, d)
        have ship broadcast "{go.name} has perished" color "red"
        if go is not None:
            do go.destroyed()
        end_if
        ->END
    else:
        have ship broadcast "{go.name} has been hurt hp={hp}" color "yellow"
    end_if
next d


jump apply_system_damage

====== damage_hallway ==============
#
# Expects loc_x and loc_y 
#  These are define in 
#
icon = 45 #fire   # 113 - Door

name_tag = "hallway:{loc_x},{loc_y}"
dam_go = grid_spawn(DAMAGE_ORIGIN_ID, name_tag, name_tag, loc_x,loc_y, icon, "red", "hallway, __damaged__") 

do link(DAMAGE_ORIGIN_ID, "damage", to_id(dam_go))
# do dam_go.blob.set("icon_scale", 0.75, 0)

jump apply_system_damage

======== apply_system_damage ======== 
#
# called by heat and internal damage handler
#
# Expects values: system_damage = a list of 4 values
#


##
## Update the systems damage
##    
blob = to_blob(sim, DAMAGE_ORIGIN_ID)
for x in range(sbs.SHPSYS.MAX):
    cur =  blob.get('system_damage', x)
    cur += system_damage[x]
    do blob.set('system_damage',cur, x)
next x

# Is this the end?
should_explode = True

for sys in range(4):
    max_damage = blob.get('system_max_damage', sys)
    current = blob.get('system_damage', sys)
    if current < max_damage:
        should_explode = False
        break
    end_if
next sys

if should_explode:
    #
    # type, subtype, source_id, target_id, x, y, z, side
    #
    pos = get_pos(sim, EVENT.origin_id)
    if pos:
        do sbs.create_transient(1, 0, EVENT.origin_id, 0, EVENT.parent_id, pos.x, pos.y, pos.z, "")  
    end_if

    do add_role(EVENT.origin_id, "exploded")

    so = to_object(EVENT.origin_id)
    engine_obj = so.space_object(sim)
    art_id = so.art_id
    do so.set_art_id(sim,"invisible")

    # Reset the systems to max
    for sys in range(4):
        do blob.set('system_damage', 0, sys)

    next sys
    
    delay sim 5s
    #
    # Reuse the score update by spawning it ourselves
    #
    schedule update_score {"DESTROYED_ID": EVENT.origin_id}

    do sim.reposition_space_object(engine_obj, so.spawn_pos.x, so.spawn_pos.y, so.spawn_pos.z)
    do so.set_art_id(sim,art_id)
    do remove_role(EVENT.origin_id, "exploded")
    SPAWNED_ID = EVENT.origin_id
    jump rebuild_grid_items
end_if

->END

