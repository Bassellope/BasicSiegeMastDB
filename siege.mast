## 
# Example shows reusable common client select
import common_console_select.mast
import common_docking.mast

logger

enemy_count=5
start_text = "Mission: Basic Siege written in Mast"

route spawn route_spawn
route change console select_console
route comms select route_comms


if IS_SERVER:
->start_server 
else: 
# client_main is in console_select
-> client_main
end_if

========== start_server ===============

section style="area: 50, 10, 99, 90;"
"""""{start_text}"""""

section style="area: 60, 75, 99, 89;"

intslider enemy_count "low: 1.0;high:50.0"

row
""" Enemies: {int(enemy_count)} """


await choice:
+ "Start Mission":
    simulation create
    simulation resume
    -> start
end_await
-> start_server


===== start ======
# Build the world

->> build_world

# Start task to watch state
=> task_end_game

# This tasks ends
->END



============ task_end_game ======= 
players = role('PlayerShip')
if len(players)==0:
    start_text = "Mission is lost!  All yer base are belong to us, dammit."
    -> start_server
end_if

raiders = role('Raider')
if len(raiders)==0:
    start_text = "Mission is won!  All the enemies have been destroyed."
    -> start_server
end_if

delay sim 4s
-> task_end_game

#############################################
# Create task to player to raider comms and station comms
#############################################

=========== route_comms  ========
# start the comms for the players and stations
# Each ship will have its of thread for comms
# this enables them to have a unique path
if has_role(COMMS_SELECTED_ID, "Station"):
    torpedo_build_type = sbs.TORPEDO.HOMING
    jump station_comms
elif has_role(COMMS_SELECTED_ID, "Raider"):
    jump npc_comms
end_if

->END

=============== station_comms ===============
comms_id = to_object(COMMS_ORIGIN_ID).comms_id
self = to_object(COMMS_SELECTED_ID)

await comms:
    + "Hail":
        homing = self.get_engine_data(sim, "torpedo_count", sbs.TORPEDO.HOMING)
        nuke = self.get_engine_data(sim, "torpedo_count", sbs.TORPEDO.NUKE)
        emp = self.get_engine_data(sim, "torpedo_count", sbs.TORPEDO.EMP)
        mine = self.get_engine_data(sim, "torpedo_count", sbs.TORPEDO.MINE)
        receive """Hello, {comms_id}.  We stand ready to assist.
You have full docking privileges.
{homing} Homing ready
{nuke} Nuke ready
{emp} EMP ready
{mine} Mine ready
{torpedo_build_type} in production.
"""
    + "Now Docking":
        receive  """We read you, {comms_id}.  We're standing by for expedited docking.^"""

    + "Hello, world":
        receive  """Hello, World"""

    + "Build Homing": 
        receive  """We read you, {comms_id}.  We will focus on homing production.^"""
        torpedo_build_type = sbs.TORPEDO.HOMING
        cancel build_task
        var build_task =>  task_station_building

    + "Build Nuke":
        receive  """We read you, {comms_id}.  We will focus on nuke production.^"""
        torpedo_build_type= sbs.TORPEDO.NUKE
        cancel build_task
        var build_task => task_station_building

    + "Build Emp":
        receive  """We read you, {comms_id}.  We will focus on EMP production.^"""
        torpedo_build_type= sbs.TORPEDO.EMP
        cancel build_task
        var build_task => task_station_building
    + "Build Mine":
        receive  """We read you, {comms_id}.  We will focus on MINE production.^"""
        torpedo_build_type = sbs.TORPEDO.MINE
        cancel build_task
        var build_task => task_station_building
end_await
-> station_comms

=== task_station_building ===
delay sim 10s
~~
cur_count = self.get_engine_data(sim, "torpedo_count", torpedo_build_type)
self.set_engine_data(sim, "torpedo_count", cur_count+1, torpedo_build_type)
~~
receive  """{comms_id}. {torpedo_build_type} Production complete."""
->task_station_building


================ npc_comms ==================
comms_id = to_object(COMMS_ORIGIN_ID).comms_id
await comms:
    + "Hail":
        receive "{comms_id}! We will destroy you, disgusting Terran scum!"
    + "You're Ugly":
        receive  """You are a foolish Terran, {comms_id}.  We know that the taunt functionality is not currently implemented.^"""
    + "Surrender now":
        receive """OK we give up, {comms_id}."""
end_await
-> npc_comms


========== route_spawn =========

# AI for the player is the docking logic
if has_role(SPAWNED_ID, "__player__"):
    jump player_docking
elif has_role(SPAWNED_ID, "raider"):
    jump task_npc_targeting
end_if

#### ELSE don't run a task
->END



========== task_npc_targeting === 

the_target = closest(SPAWNED_ID, role("PlayerShip"), 2000)
if the_target is None:
    the_target = closest(SPAWNED_ID, role("Station"))
end_if
if the_target is not None:
    do target(sim, SPAWNED_ID, the_target, True)
end_if


delay sim 5s
-> task_npc_targeting



================= build_world ===================

player_ships =  ~~[ (500,0,0, "Artemis", "tsn", "tsn_battle_cruiser"),
                (200,0,0, "Hera", "tsn", "tsn_missile_cruiser"),
                ( 900,0,0, "Atlas", "tsn", "tsn_missile_cruiser")
]~~

first = True
for player_args in player_ships:
    player_ship = to_id(player_spawn(*player_args))
    do set_face(player_ship, random_terran())
    if first:
        do assign_client_to_ship(0,player_ship)
        first = False
    end_if
next player_args

stations = [(0,0,0, "Alpha"),(2400,0,100, "Beta")]
for station in stations:
    ds = to_id(npc_spawn(*station, "tsn", "starbase_command", "behav_station"))
    do add_role(ds, "Station")
    do set_face(ds, random_terran(civilian=True))
next station 


enemyTypeNameList = ["kralien_dreadnaught","kralien_battleship","skaraan_defiler","cargo_ship","arvonian_carrier","torgoth_behemoth"]
enemy_prefix = "KLMNQ"


enemy = 0
spawn_points = scatter_sphere(int(enemy_count), 0,0,0, 6000, 6000+250*enemy_count, ring=True)

for v in spawn_points:
    r_type = random.choice(enemyTypeNameList)
    r_name = f"{random.choice(enemy_prefix)}_{enemy}"
    spawn_data = npc_spawn(v.x, v.y, v.z, r_name, "RAIDER", r_type, "behav_npcship")
    raider = spawn_data.py_object
    do set_face(raider.id, random_kralien())
    do add_role(raider.id, "Raider")
    enemy = enemy + 1
next v


# make a few random clusters of nebula
spawn_points = scatter_sphere(random.randint(2,7), 0,0,0, 1000, 4000, ring=True)
for v in spawn_points:
    cluster_spawn_points = scatter_sphere(random.randint(3,9), v.x, 0,v.z, 100, 1000, ring=True)
    for v2 in cluster_spawn_points:
        do terrain_spawn(v2.x, v2.y, v2.z,None, None, "nebula", "behav_nebula")
    next v2
next v

# make a few random clusters of Asteroids
spawn_points = scatter_sphere(random.randint(10,20), 0,0,0, 1000, 4000, ring=True)
asteroid_types = names_asteroid_keys()
for v in spawn_points:
    cluster_spawn_points = scatter_sphere(random.randint(10,20), v.x, 0,v.z, 100, 1000, ring=False)
    for v2 in cluster_spawn_points:
        #keep value between -500 and 500??
        v2.y = abs(v2.y) % 500 * (v2.y/abs(v2.y))
        a_type = random.choice(asteroid_types)
        #a_type = "asteroid_crystal_blue"
        do terrain_spawn(v2.x, v2.y, v2.z,None, None, a_type, "behav_asteroid")
    next v2
next v

# I want candy
spawn_points = scatter_sphere(random.randint(5,12), 0,0,0, 1000, 4000, ring=True)
for v in spawn_points:
    cluster_spawn_points = scatter.sphere(random.randrange(10,20), v.x, 0,v.z, 100, 1000, ring=False)
    # Random type, but same for cluster
    a_type = f"danger_{random.randint(1,5)}{random.choice('abc')}"
    for v2 in cluster_spawn_points:
        #keep value between -500 and 500??
        v2.y = abs(v2.y) % 500 * (v2.y/abs(v2.y))
        do terrain_spawn(v2.x, v2.y, v2.z,None, None, a_type, "behav_mine")
    next v2
next v
<<-
